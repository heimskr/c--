#name "Why ISA Tests"
#author "Kai Tamkun"
#orcid "0000-0001-7405-6654"
#version "8.1"

struct String {
	u8* data;
	u64 size;
	u64 capacity;
};

void*[8] table;
s64 delay = 300000;
u8* timeup = "Time's up\n";
void()* timer_ptr = int_timer;
s64(s64)* fnptr = add5;
%String input;
u64 npos = 0u64;

s64 double(s64 n) {
	return n << 1;
}

s64 add5(s64 n) {
	return n + 5;
}

void main() {
	--npos;
	void* g;
	asm("$g -> $1"::g);
	p("$g = "); p((u64) g); p('\n');
	void *mem;
	asm("$g -> $1"::g);
	asm("? mem -> $1"::mem);
	setBounds(g, mem);
	%String::init(&input, "");
	table[2] = timer_ptr;
	table[7] = int_keybrd;
	asm("%rit table");
	while (true)
		asm("<rest>");
}

s64(s64)* swap(s64(s64)* f) {
	if (f == double)
		return add5;
	return double;
}

void int_keybrd_(u64 key_full) {
	u8 key = (u8) key_full;
	bool ctrl = (bool) ((key_full >> 34u64) & 1u64);
	if (key_full == 0u64) { // Ctrl-Space, for some reason.
		fnptr = swap(fnptr);
		p("Swapped function pointers.\n");
	} else if (ctrl) {
		if (key == 'a') {
			p("You pressed ^a :)\n");
		} else if (key == '=') {
			delay = delay * 11 / 10;
			p("Delay: "); p(delay); p('\n');
		} else if (key == '-') {
			delay = delay * 10 / 11;
			p("Delay: "); p(delay); p('\n');
		} else if (key == '\x0d') { // Ctrl-Enter, for some reason.
			asm("%time $1":delay:);
		} else if (key == '8') {
			p("20 -> ");
			s64(s64)* hacked_ptr = (s64(s64)*) (((s64) fnptr << 1) + 8);
			p(((s64(s64)*)((s64) ((s16*) hacked_ptr - 4s16) / 2))(20));
			p('\n');
		} else if (key == 'h') {
			hack();
		} else if (key == 's') {
			%String str1 = [null, 0, 0];
			%String str2 = [null, 0, 0];
			%String::init(&str1, "Hello");
			%String::init(&str2, " there");
			str1::append(&str2);
			str1::append(", how are you");
			str1::append('?');
			str1::debug();
			str1::free();
			str2::free();
		} else if (key == 't') {
			traverseBlocks();
		}
		else { p("You pressed '"); p(key); p('\''); p(" ~ "); asm("<prx $1>":key); p(" ~ "); asm("<prx $1>":key_full); p('\n'); }
	} else if (key == '\x7f') { // Backspace
		input::pop();
		p("\e[D \e[D");
	} else if (key == '\n') {
		p("\e[2K\e[G");
		%StringVec* split = %StringVec::split(&input, " ");
		input::clear();
		p("Split size("); p(split->size); p(")\n");
		for (u64 i = 0; i < split->size; ++i) {
			p(i); p('('); p((*split)::at(i)->size); p("): "); (*(*split)::at(i))::print(); p('\n');
		}
		(*split)::eviscerate();
	} else {
		input::append(key);
		p(key);
		// p("\e[2K\e[G");
		// p(input.data);
		// p(' '); p(input.size);
	}
}

void int_keybrd() #naked {
	asm("[ $rt; [ $a0");
	asm("$e2 -> $a0; :: _11int_keybrd_v1u8");
	asm("] $a0; ] $rt");
	asm(": ] %page $e0");
}

void int_timer() #naked {
	asm("[ $rt");
	asm("[ $a0");
	asm("[timeup] -> $a0");
	asm(":: `s");
	asm("[delay] -> $a0");
	asm("%time $a0");
	asm("] $a0");
	asm("] $rt");
	asm(": ] %page $e0");
}

bool hacked = false;

void hack() {
	if (hacked)
		return;
	s32* what = (s32*) &add5;
	p(what); p('\n');
	for (s64 i = 0; i < 1000; ++i) {
		if (*++what == 5s32)
			p("\x1b[32m");
		p((s64) what);
		p(": ");
		asm("<prx $1>":*what);
		p("\x1b[0m\n");
		if (*what == 5s32) {
			*what = 42s32;
			p("hacked =)\n");
			hacked = true;
			fnptr = add5;
			break;
		}
	}
	if (!hacked)
		p("not hacked =(\n");
}

void memcpy(void* destination, void* source, u64 count) {
	// p("\e[35mmemcpy("); p(destination); p(", "); p(source); p(", "); p(count); p(")\e[39m\n");
	while (8u64 <= count) {
		asm("[$1] -> [$2]":source, destination);
		count -= 8u64;
		source += 8u64;
		destination += 8u64;
	}
	while (4u64 <= count) {
		asm("[$1] -> [$2] /h":source, destination);
		count -= 4u64;
		source += 4u64;
		destination += 4u64;
	}
	while (2u64 <= count) {
		asm("[$1] -> [$2] /s":source, destination);
		count -= 2u64;
		source += 2u64;
		destination += 2u64;
	}
	while (0u64 < count) {
		asm("[$1] -> [$2] /b":source, destination);
		--count;
		++source;
		++destination;
	}
}

u8* String::copyData(u64* new_capacity) {
	*new_capacity = roundUp(this->size + 1u64);
	u8* out = new(*new_capacity);
	if (this->data)
		memcpy(out, this->data, this->size);
	out[this->size] = '\0';
	return out;
}

u8* String::copyData() {
	u8* out = new(this->size + 1u64);
	if (this->data)
		memcpy(out, this->data, this->size);
	out[this->size] = '\0';
	return out;
}

void String::append(%String* source) {
	u64 required = source->size + this->size + 1u64;
	if (this->capacity < required) {
		//// asm("<print $1>":42);
		u8* old_data = this->data;
		this->data = (*this)::copyData(&required);
		if (old_data)
			free(old_data);
		this->capacity = required;
	}
	memcpy(this->data + this->size, source->data, source->size);
	this->size += source->size;
	this->data[this->size] = '\0';
}

void String::append(u8* other) {
	u64 other_len = strlen(other);
	u64 required = other_len + this->size + 1u64;
	if (this->capacity < required) {
		//// asm("<print $1>":43);
		u8* old_data = this->data;
		this->data = (*this)::copyData(&required);
		if (old_data)
			free(old_data);
		this->capacity = required;
	}
	memcpy(this->data + this->size, other, other_len);
	this->size += other_len;
	this->data[this->size] = '\0';
}

void String::append(u8 ch) {
	u64 required = this->size + 2u64;
	if (this->capacity < required) {
		//// asm("<print $1>; <print $2>; <print $3>":404,this->capacity,required);
		u8* old_data = this->data;
		this->data = (*this)::copyData(&required);
		//// asm("<print $1>; <print $2>; <print $3>":this->capacity,required,405);
		if (old_data)
			free(old_data);
		this->capacity = required;
	}
	this->data[this->size++] = ch;
	//// asm("<print $k0>");
	//// asm("<print $1>; <print $2>":this->capacity,&this->capacity);
	this->data[this->size] = '\0';
}

void String::set(u8* new_data) {
	u64 required = strlen(new_data) + 1u64;
	if (this->capacity < required) {
		u8* old_data = this->data;
		this->data = (*this)::copyData(&required);
		if (old_data)
			free(old_data);
		this->capacity = required;
	}
	memcpy(this->data, new_data, required - 1u64);
	this->data[this->size] = '\0';
}

void String::free() {
	if (this->data) {
		free(this->data);
		this->data = null;
	}
	this->size = 0u64;
	this->capacity = 0u64;
}

void String::debug() {
	p(" \e[2mptr:\e[22m "); p((void*) this->data); p('\n');
	p("\e[2mdata:\e[22m "); p(this->data); p('\n');
	p("\e[2msize:\e[22m "); p(this->size); p('\n');
	p(" \e[2mcap:\e[22m "); p(this->capacity); p('\n');
}

void String::pop() {
	if (this->size == 0u64)
		return;
	this->data[--this->size] = '\0';
}

void String::clear() {
	if (this->capacity != 0u64) {
		this->size = 0u64;
		this->data[0] = '\0';
	}
}

void String::move(%String* other) {
	other->size = this->size;
	other->capacity = this->capacity;
	other->data = this->data;
	this->data = null;
	this->size = 0;
	this->capacity = 0;
}

static void String::init(%String* out, u8* data) {
	u64 len = strlen(data);
	out->data = strcpy(data);
	out->capacity = (out->size = len) + 1u64;
	p("out->size = "); p(out->size); p(" <- "); p(len); l();
}

void String::print() {
	for (u64 i = 0; i < this->size; ++i)
		p(this->data[i]);
}

u64 String::find(u8 ch, u64 start) {
	for (u64 i = start; i < this->size; ++i)
		if (this->data[i] == ch)
			return i;
	return npos;
}

// Probably rather inefficient.
u64 String::find(u8 const* str, u64 start) {
	u64 const len = strlen(str);
	if (len == 0u64 || this->size < len)
		return npos;

	p("this->size["); p(this->size); p("], len["); p(len); p("]\n");

	for (u64 i = start; i <= this->size - len; ++i) {
		bool should_return = true;
		for (u64 j = 0u64; j < len; ++j)
			if (this->data[i + j] != str[j]) {
				should_return = false;
				break;
			}
		if (should_return)
			return i;
	}
	return npos;
}

u64 String::find(%String* str, u64 start) {
	u64 const len = str->size;
	u64 const max = this->size - len;
	if (len == 0u64)
		return npos;
	for (u64 i = start; i <= max; ++i) {
		bool should_return = true;
		for (u64 j = 0u64; j < len; ++j)
			if (this->data[i + j] != str->data[j]) {
				should_return = false;
				break;
			}
		if (should_return)
			return i;
	}
	return npos;
}

bool String::empty() {
	return this->size == 0u64;
}

void String::reserve(u64 size) {
	++size;
	if (this->capacity < size) {
		u8* old_data = this->data;
		this->data = (*this)::copyData(&size);
		if (old_data)
			free(old_data);
		this->capacity = size;
	}
}

static %String* String::new(u8* data) {
	%String* out = new(sizeof(%String));
	%String::init(out, data);
	return out;
}

static %String* String::new() {
	%String* out = new(sizeof(%String));
	%String::init(out, "");
	return out;
}

%String* String::substr(u64 start, u64 len) {
	%String* out = %String::new("");
	(*out)::reserve(len);

	for (u64 i = 0; i < len; ++i) {
		if (this->size <= i + start)
			break;
		(*out)::append(this->data[start + i]);
	}

	return out;
}

void String::eviscerate() {
	(*this)::free();
	free(this);
}

struct StringVec {
	%String* data;
	u64 size;
	u64 capacity;
};

%String* StringVec::at(u64 index) {
	if (this->size <= index)
		panic("Invalid index in StringVec::at");
	return &this->data[index];
}

%String* StringVec::front() {
	if (this->size == 0u64)
		panic("Container empty in StringVec::front");
	return this->data;
}

%String* StringVec::back() {
	if (this->size == 0u64)
		panic("Container empty in StringVec::back");
	return &this->data[this->size - 1u64];
}

%String* StringVec::copyData(u64* new_capacity) {
	p("\e[32mcopyData: "); p((void*) this->data); p(", "); p(this->size); p(" @ "); p(&this->size); p(", "); p(this->capacity); p("\e[0m ");
	%String* out = new((*new_capacity = roundUp(this->size + 1u64)) * sizeof(%String));
	p("this->size @ "); p(&this->size); p(" = "); p(this->size); p('\n');
	p("*new_capacity = "); p(*new_capacity); p('\n');
	if (this->data)
		memcpy(out, this->data, this->size * sizeof(%String));
	return out;
}

void StringVec::freeData() {
	if (!this->data)
		return;
	for (u64 i = 0; i < this->size; ++i)
		this->data[i]::free();
	free(this->data);
	this->data = null;
}

void StringVec::adjust(u64 *required) {
	p("\e[33madjust: "); p((void*) this->data); p(", "); p(this->size); p(", "); p(this->capacity); p("\e[0m\n");
	if (this->capacity < *required || !this->data) {
		%String* new_data = (*this)::copyData(required);
		// (*this)::freeData();
		if (this->data) {
			p("adjust(u64*): free "); p((void*) this->data); l();
			free(this->data);
		}
		this->data = new_data;
		this->capacity = *required;
	}
}

void StringVec::absorb(%String* str) {
	u64 required = this->size + 1u64;
	(*this)::adjust(&required);
	memcpy(&this->data[this->size++], str, sizeof(%String));
	p("absorb(%String*): free "); p((void*) str); l();
	(*str)::free();
}

void StringVec::push(%String* str) {
	u64 required = this->size + 1u64;
	p("\e[34m[1] (@"); p(this); p(": "); p((void*) this->data); p(", "); p(this->size); p(", "); p(this->capacity); p("\e[0m\n");
	p("\e[34m"); p((void*) str->data); p(", "); p(str->size); p(", "); p(str->capacity); p(")\e[0m\n");

	(*this)::adjust(&required);
	p("\e[36m[2] (@"); p(this); p(": "); p((void*) this->data); p(", "); p(this->size); p(", "); p(this->capacity); p("\e[0m\n");
	p("\e[36m"); p((void*) str->data); p(", "); p(str->size); p(", "); p(str->capacity); p(")\e[0m\n");
	p("(("); (*str)::print(); p(")):"); p((u64) str->data[0]); p('\n');
	p("\e[32min StringVec::push [1]: "); p((void*) this->data); p(", "); p(this->size); p(" @ "); p(&this->size); p(", "); p(this->capacity); p("\e[0m ");
	u8* data_copy = (*str)::copyData();
	u64 s = strlen(data_copy);
	p("<<"); p(s); p(">>\n");
	for (u64 i = 0; i < s; ++i) { p((u64) data_copy[i]); p(' '); } p('\n');
	p("[["); p(strlen(str->data)); p("]]\n");
	p("\e[32min StringVec::push [2]: "); p((void*) this->data); p(", "); p(this->size); p(" @ "); p(&this->size); p(", "); p(this->capacity); p("\e[0m ");
	this->data[this->size].data = data_copy;
	this->data[this->size].size = str->size;
	this->data[this->size].capacity = str->size + 1u64;


	++this->size;

	// this->capacity = required;
}

void StringVec::push(u8* str) {
	u64 required = this->size + 1u64;
	(*this)::adjust(&required);
	%String::init(&this->data[this->size++], str);
	this->capacity = required;
}

static %StringVec* StringVec::new() {
	%StringVec* out = new(sizeof(%StringVec));
	out->data = null;
	out->size = 0;
	out->capacity = 0;
	p("out("); p(out); p("): "); p((void*) out->data); p(", "); p(out->size); p(", "); p(out->capacity); p("\e[0m\n");
	return out;
}

void StringVec::eviscerate() {
	(*this)::freeData();
	this->size = 0;
	this->capacity = 0;
	free(this);
}

static %StringVec* StringVec::split(%String* str, u8* delimiter) {
	p("Splitting \"");
	(*str)::print();
	p("\" ");
	p(str);
	p(' ');
	p((void*) str->data);
	p('\n');
	%StringVec* sv = %StringVec::new();
	if ((*str)::empty()) {
		p("Splitting done; empty.\n");
		return sv;
	}

	p("[1] sv @ "); p(sv); p(": "); p((void*) sv->data); p(", "); p(sv->size); p(", "); p(sv->capacity); p("\e[0m\n");
	p('%'); (*str)::print(); p('%'); p(sv); p(' '); p(str); p(' '); p((void*) str->data); p('\n');

	// Something interesting: if I use 0(s64) as the second argument or leave out the second argument altogether,
	// the overloading logic finds *multiple* candidates instead of the expected zero candidates.
	u64 next = (*str)::find(delimiter, 0u64);
	if (next == npos) {
		p("Splitting done; returning trivial vector.\n");
		p("\e[32m(next == npos): "); p((void*) sv->data); p(", "); p(sv->size); p(" @ "); p(&sv->size); p(", "); p(sv->capacity); p("\e[0m ");
		(*sv)::push(str);
		return sv;
	}

	p("\e[32m(next == "); p(next); p("): "); p((void*) sv->data); p(", "); p(sv->size); p(" @ "); p(&sv->size); p(", "); p(sv->capacity); p("\e[0m ");
	u64 const delimiter_size = strlen(delimiter);
	p("delimiter_size["); p(delimiter_size); p("], next["); p(next); p("]\n");
	u64 last = 0u64;

	p("[2] sv @ "); p(sv); p(": "); p((void*) sv->data); p(", "); p(sv->size); p(", "); p(sv->capacity); p("\e[0m\n");
	asm("$1 -> $k2; <print $k2>":sv);
	(*sv)::push((*str)::substr(0u64, next));

	p("!\n");

	while (next != npos) {
		last = next;
		next = (*str)::find(delimiter, last + delimiter_size);
		p("<["); p(last + delimiter_size); p(", "); p(next - last - delimiter_size); p(", next("); p(next); p("), last("); p(last); p(")]>\n");
		%String* sub = (*str)::substr(last + delimiter_size, next - last - delimiter_size);
		p("Sub[");
		(*sub)::print();
		p("]\n");
		(*sv)::absorb(sub);
		free(sub);
	}

	p("Split fully.\n");
	return sv;
}

void panic(u8* message) {
	p("\e[31mERROR\e[0m: ");
	p(message);
	p('\n');
	asm("<halt>");
}

u64 strlen(u8 const* string) {
	u64 out = 0u64;
	for (; string[out]; ++out);
	return out;
}

u8* strcpy(u8 const* string) {
	u64 const len = strlen(string);
	u8* out = new(len + 1u64);
	memcpy(out, string, len);
	out[len] = '\0';
	return out;
}

void l() { asm("<prc $1>":'\n'); }
void p(u8* s)     { `s(s);                   }
void p(u64 n)     { `u64(n);                 }
void p(s64 n)     { `s64(n);                 }
void p(void* ptr) { `ptr(ptr);               }
void p(u8 ch)     { `c(ch);                  }
void p(bool b)    { `s(b? "true" : "false"); }

struct BlockMeta;

u64 MEMORY_ALIGN = 32u64;
u64 allocated = 0u64;
%BlockMeta* base = null;
u64 highestAllocated = 0u64;
void* start = null;
void* high = null;
void* end = null;

struct BlockMeta {
	u64 size;
	%BlockMeta* next;
	bool free;
};

u64 realign(u64 val, u64 alignment) {
	if (alignment == 0u64)
		return val;
	// p("\e[2mrealign: "); asm("<prx $1>":val); p(" -> ");
	u64 offset = (val + sizeof(%BlockMeta)) % alignment;
	if (offset)
		val += alignment - offset;
	// asm("<prx $1>":val); p("\e[22m\n");
	return val;
}

%BlockMeta* findFreeBlock(%BlockMeta** last, u64 size) {
	%BlockMeta* current = base;
	// asm("$1 -> $k0; <print $k0>":&current->next);
	// p("Start: "); p(current); p('\n');
	while (current && !(current->free && size <= current->size)) {
		*last = current;
		current = current->next;
		// asm("$1 -> $k1; <print $k1>":current);
		// p("Current: "); p(current); p('\n');
	}
	return current;
}

%BlockMeta* requestSpace(%BlockMeta* last, u64 size, u64 alignment) {
	%BlockMeta* block = (%BlockMeta*) realign((u64) end, alignment);

	if (last) {
		// p("last->next: "); p(last->next); p(" -> ");
		last->next = block;
		// p(last->next); l();
	}

	block->size = size;
	// p("block->next: "); p(block->next); p(" -> ");
	block->next = null;
	// p(block->next); l();
	block->free = false;

	// p("\e[2mend: "); p(end); p(" -> ");
	end = (u8*) block + block->size + sizeof(%BlockMeta) + 1;
	// p(end); p("\e[22m\n");
	return block;
}

void* allocate(u64 size, u64 alignment) {
	%BlockMeta* block = null;

	// p("allocate("); p(size); p(", "); p(alignment); p(")\n");

	if (!base) {
		block = requestSpace(null, size, alignment);
		if (!block)
			return null;
		base = block;
	} else {
		%BlockMeta* last = base;
		block = findFreeBlock(&last, size);
		if (!block) {
			block = requestSpace(last, size, alignment);
			if (!block)
				return null;
		} else {
			split(block, size);
			block->free = false;
		}
	}

	allocated += block->size + sizeof(%BlockMeta);
	return block + 1;
}

void traverseBlocks() {
	%BlockMeta* block = base;
	p("Total allocated: "); p(allocated); p('\n');
	while (block) {
		p(block); p(' '); p(block->free); p(' '); p(block->size); p('\n');
		block = block->next;
	}
}

void split(%BlockMeta* block, u64 size) {
	if (block->size > size + sizeof(%BlockMeta)) {
		// We have enough space to split the block, unless alignment takes up too much.
		%BlockMeta* new_block = (%BlockMeta*) realign((u64) block + size + sizeof(%BlockMeta) + 1u64, MEMORY_ALIGN);

		// After we realign, we need to make sure that the new block's new size isn't negative.

		if (block->next) {
			u64 new_size = (u64) ((void*) block->next - (void*) new_block - (s64) sizeof(%BlockMeta));

			// Realigning the new block can make it too small, so we need to make sure the new block is big enough.
			if (new_size > 0u64) {
				new_block->size = new_size;
				new_block->free = true;
				new_block->next = block->next;
				// p("new_block->next = "); p(new_block->next); l();
				block->next = new_block;
				// p("block->next = "); p(block->next); l();
				block->size = size;
			}
		} else {
			u64 new_size = (u64) ((void*) block + block->size - (void*) new_block);

			if (new_size > 0u64) {
				new_block->size = new_size;
				new_block->free = true;
				new_block->next = null;
				p("new_block->next = "); p(new_block->next); l();
				block->size = size;
				block->next = new_block;
				p("block->next = "); p(block->next); l();
			}
		}
	}
}

%BlockMeta* getBlock(void* ptr) {
	return (%BlockMeta*) ptr - 1;
}

void free(void* ptr) {
	if (ptr == null)
		return;
	// p("\e[1;2mfree("); p(ptr); p(")\e[22m\n");
	%BlockMeta* block_ptr = getBlock(ptr);
	block_ptr->free = true;
	if (!block_ptr->next)
		end = block_ptr;
	allocated -= block_ptr->size + sizeof(%BlockMeta);
	merge();
}

u64 merge() {
	u64 count = 0u64;
	%BlockMeta* current = base;
	while (current && current->next) {
		// p("\e[36m"); p(current); p("\e[0m\n");
		if (current->free && current->next->free) {
			current->size += sizeof(%BlockMeta) + current->next->size;
			current->next = current->next->next;
			// p("current->next = "); p(current->next); l();
			++count;
		} else
			current = current->next;
	}

	return count;
}

void setBounds(void* new_start, void* new_high) {
	if (new_high <= new_start) {
		p("Invalid heap bounds: 0x");
		asm("<prx $1>":new_start);
		p(" through 0x");
		asm("<prx $1>":new_high);
		p('\n');
		asm("<halt>");
	}
	start = (void*) realign((u64) new_start, MEMORY_ALIGN);
	highestAllocated = (u64) start;
	high = new_high;
	end = new_start;
}

u64 getUnallocated() {
	return (u64) (high - start) - allocated;
}

void* malloc(u64 size) {
	return allocate(size, MEMORY_ALIGN);
}

void* memset(void* ptr, u8 c, u64 len) {
	asm("memset $1 x $2 -> $3":len, c, ptr);
	return ptr;
}

void* calloc(u64 count, u64 size) {
	void* chunk = malloc(count * size);
	if (chunk)
		memset(chunk, 0, count * size);
	return chunk;
}

void* new(u64 size) {
	void* out = malloc(size);
	if (!out) {
		p("Can't allocate ");
		p(size);
		p(" bytes: out of memory\n");
		asm("<halt>");
	}
	return out;
}

u64 roundUp(u64 value) {
	--value;
	value |= value >> 1u64;
	value |= value >> 2u64;
	value |= value >> 4u64;
	value |= value >> 8u64;
	value |= value >> 16u64;
	value |= value >> 32u64;
	return ++value;
}
