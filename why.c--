#name "Why ISA Tests"
#author "Kai Tamkun"
#orcid "0000-0001-7405-6654"
#version "7.0"

struct String {
	u8* data;
	u64 size;
	u64 capacity;
};

void*[8] table;
s64 delay = 300000;
u8* timeup = "Time's up\n";
void()* timer_ptr = int_timer;
s64(s64)* fnptr = add5;
%String input;

s64 double(s64 n) {
	return n << 1;
}

s64 add5(s64 n) {
	return n + 5;
}

void main() {
	void* g;
	asm("$g -> $1"::g);
	p("$g = "); p((u64) g); p('\n');
	void *mem;
	asm("$g -> $1"::g);
	asm("? mem -> $1"::mem);
	setBounds(g, mem);
	%String::init(&input, "");
	table[2] = timer_ptr;
	table[7] = int_keybrd;
	asm("%rit table");
	while (true)
		asm("<rest>");
}

s64(s64)* swap(s64(s64)* f) {
	if (f == double)
		return add5;
	return double;
}

void int_keybrd_(u64 key_full) {
	u8 key = (u8) key_full;
	bool ctrl = (bool) ((key_full >> 34u64) & 1u64);
	if (key_full == 0u64) { // Ctrl-Space, for some reason.
		fnptr = swap(fnptr);
		p("Swapped function pointers.\n");
	} else if (ctrl) {
		if (key == 'a') {
			p("You pressed ^a :)\n");
		} else if (key == '=') {
			delay = delay * 11 / 10;
			p("Delay: "); p(delay); p('\n');
		} else if (key == '-') {
			delay = delay * 10 / 11;
			p("Delay: "); p(delay); p('\n');
		} else if (key == '\x0d') { // Ctrl-Enter, for some reason.
			asm("%time $1":delay:);
		} else if (key == '8') {
			p("20 -> ");
			s64(s64)* hacked_ptr = (s64(s64)*) (((s64) fnptr << 1) + 8);
			p(((s64(s64)*)((s64) ((s16*) hacked_ptr - 4s16) / 2))(20));
			p('\n');
		} else if (key == 'h') {
			hack();
		} else if (key == 's') {
			%String str1 = [null, 0, 0];
			%String str2 = [null, 0, 0];
			%String::init(&str1, "Hello");
			%String::init(&str2, " there");
			str1::append(&str2);
			str1::append(", how are you");
			str1::append('?');
			str1::debug();
			str1::free();
			str2::free();
		} else if (key == 't') {
			traverse_blocks();
		}
		else { p("You pressed '"); p(key); p('\''); p(" ~ "); asm("<prx $1>":key); p(" ~ "); asm("<prx $1>":key_full); p('\n'); }
	} else if (key == '\x7f') { // Backspace
		input::pop();
		p("\e[2K\e[G");
		p(input.data);
	} else if (key == '\n') {
		input::clear();
		p("\e[2K\e[G");
		p(input.data);
	} else {
		input::append(key);
		p("\e[2K\e[G");
		p(input.data);
		p(' '); p(input.size);
	}
}

void int_keybrd() #naked {
	asm("[ $rt; [ $a0");
	asm("$e2 -> $a0; :: _11int_keybrd_v1u8");
	asm("] $a0; ] $rt");
	asm(": ] %page $e0");
}

void int_timer() #naked {
	asm("[ $rt");
	asm("[ $a0");
	asm("[timeup] -> $a0");
	asm(":: `s");
	asm("[delay] -> $a0");
	asm("%time $a0");
	asm("] $a0");
	asm("] $rt");
	asm(": ] %page $e0");
}

bool hacked = false;

void hack() {
	if (hacked)
		return;
	s32* what = (s32*) &add5;
	p(what); p('\n');
	for (s64 i = 0; i < 1000; ++i) {
		if (*++what == 5s32)
			p("\x1b[32m");
		p((s64) what);
		p(": ");
		asm("<prx $1>":*what);
		p("\x1b[0m\n");
		if (*what == 5s32) {
			*what = 42s32;
			p("hacked =)\n");
			hacked = true;
			fnptr = add5;
			break;
		}
	}
	if (!hacked)
		p("not hacked =(\n");
}

void memcpy(void* destination, void* source, u64 count) {
	while (8u64 <= count) {
		asm("[$1] -> [$2]":source, destination);
		count -= 8u64;
		source += 8u64;
		destination += 8u64;
	}
	while (4u64 <= count) {
		asm("[$1] -> [$2] /h":source, destination);
		count -= 4u64;
		source += 4u64;
		destination += 4u64;
	}
	while (2u64 <= count) {
		asm("[$1] -> [$2] /s":source, destination);
		count -= 2u64;
		source += 2u64;
		destination += 2u64;
	}
	while (0u64 < count) {
		asm("[$1] -> [$2] /b":source, destination);
		--count;
		++source;
		++destination;
	}
}

u8* String::copyData(u64* new_capacity) {
	u8* out = new(*new_capacity = roundUp(this->size + 1u64));
	memcpy(out, this->data, this->size);
	out[this->size] = '\0';
	return out;
}

void String::append(%String* source) {
	u64 required = source->size + this->size + 1u64;
	if (this->capacity < required) {
		if (this->data)
			free(this->data);
		this->data = (*this)::copyData(&required);
	}
	memcpy(this->data + this->size, source->data, source->size);
	this->size += source->size;
	this->capacity = required;
	this->data[this->size] = '\0';
}

void String::append(u8* other) {
	u64 other_len = strlen(other);
	u64 required = other_len + this->size + 1u64;
	if (this->capacity < required) {
		if (this->data)
			free(this->data);
		this->data = (*this)::copyData(&required);
	}
	memcpy(this->data + this->size, other, other_len);
	this->size += other_len;
	this->capacity = required;
	this->data[this->size] = '\0';
}

void String::append(u8 ch) {
	u64 required = this->size + 2u64;
	if (this->capacity < required) {
		if (this->data)
			free(this->data);
		this->data = (*this)::copyData(&required);
	}
	this->data[this->size++] = ch;
	this->capacity = required;
	this->data[this->size] = '\0';
}

void String::set(u8* new_data) {
	u64 required = strlen(new_data) + 1u64;
	if (this->capacity < required) {
		if (this->data)
			free(this->data);
		this->data = (*this)::copyData(&required);
	}
	memcpy(this->data, new_data, required - 1u64);
	this->capacity = required;
	this->data[this->size] = '\0';
}

void String::free() {
	if (this->data) {
		free(this->data);
		this->data = null;
	}
	this->size = 0u64;
	this->capacity = 0u64;
}

void String::debug() {
	p(" \e[2mptr:\e[22m "); p((void*) this->data); p('\n');
	p("\e[2mdata:\e[22m "); p(this->data); p('\n');
	p("\e[2msize:\e[22m "); p(this->size); p('\n');
	p(" \e[2mcap:\e[22m "); p(this->capacity); p('\n');
}

void String::pop() {
	if (this->size == 0u64)
		return;
	this->data[--this->size] = '\0';
}

void String::clear() {
	if (this->capacity != 0u64) {
		this->size = 0u64;
		this->data[0] = '\0';
	}
}

static void String::init(%String* out, u8* data) {
	u64 len = strlen(data);
	out->data = strcpy(data);
	out->capacity = (out->size = len) + 1u64;
}

u64 strlen(u8* string) {
	u64 out = 0u64;
	for (; string[out]; ++out);
	return out;
}

u8* strcpy(u8* string) {
	u64 const len = strlen(string);
	u8* out = new(len + 1u64);
	memcpy(out, string, len);
	out[len] = '\0';
	return out;
}

void p(u8* s)     { `s(s);                   }
void p(u64 n)     { `u64(n);                 }
void p(s64 n)     { `s64(n);                 }
void p(void* ptr) { `ptr(ptr);               }
void p(u8 ch)     { `c(ch);                  }
void p(bool b)    { `s(b? "true" : "false"); }

struct BlockMeta;

u64 MEMORY_ALIGN = 32u64;
u64 allocated = 0u64;
%BlockMeta* base = null;
u64 highestAllocated = 0u64;
void* start = null;
void* high = null;
void* end = null;

struct BlockMeta {
	u64 size;
	%BlockMeta* next;
	bool free;
};

u64 realign(u64 val, u64 alignment) {
	if (alignment == 0u64)
		return val;
	u64 offset = (val + sizeof(%BlockMeta)) % alignment;
	if (offset)
		val = val + alignment - offset;
	return val;
}

%BlockMeta* findFreeBlock(%BlockMeta** last, u64 size) {
	%BlockMeta* current = base;
	while (current && !(current->free && size <= current->size)) {
		*last = current;
		current = current->next;
	}
	return current;
}

%BlockMeta* requestSpace(%BlockMeta* last, u64 size, u64 alignment) {
	%BlockMeta* block = (%BlockMeta*) realign((u64) end, alignment);

	if (last)
		last->next = block;

	block->size = size;
	block->next = null;
	block->free = false;

	end = (u8*) block + block->size + sizeof(%BlockMeta) + 1;
	return block;
}

void* allocate(u64 size, u64 alignment) {
	%BlockMeta* block = null;

	if (!base) {
		block = requestSpace(null, size, alignment);
		if (!block)
			return null;
		base = block;
	} else {
		%BlockMeta* last = base;
		block = findFreeBlock(&last, size);
		if (!block) {
			block = requestSpace(last, size, alignment);
			if (!block)
				return null;
		} else {
			split(block, size);
			block->free = false;
		}
	}

	allocated += block->size + sizeof(%BlockMeta);
	return block + 1;
}

void traverse_blocks() {
	%BlockMeta* block = base;
	p("Total allocated: "); p(allocated); p('\n');
	while (block) {
		p(block); p(' '); p(block->free); p(' '); p(block->size); p('\n');
		block = block->next;
	}
}

void split(%BlockMeta* block, u64 size) {
	if (block->size > size + sizeof(%BlockMeta)) {
		// We have enough space to split the block, unless alignment takes up too much.
		%BlockMeta* new_block = (%BlockMeta*) realign((u64) block + size + sizeof(%BlockMeta) + 1u64, MEMORY_ALIGN);

		// After we realign, we need to make sure that the new block's new size isn't negative.

		if (block->next) {
			u64 new_size = (u64) ((void*) block->next - (void*) new_block - (s64) sizeof(%BlockMeta));

			// Realigning the new block can make it too small, so we need to make sure the new block is big enough.
			if (new_size > 0u64) {
				new_block->size = new_size;
				new_block->free = true;
				new_block->next = block->next;
				block->next = new_block;
				block->size = size;
			}
		} else {
			u64 new_size = (u64) ((void*) block + block->size - (void*) new_block);

			if (new_size > 0u64) {
				new_block->size = new_size;
				new_block->free = true;
				new_block->next = null;
				block->size = size;
				block->next = new_block;
			}
		}
	}
}

%BlockMeta* getBlock(void* ptr) {
	return (%BlockMeta*) ptr - 1;
}

void free(void* ptr) {
	if (ptr == null)
		return;
	%BlockMeta* block_ptr = getBlock(ptr);
	block_ptr->free = true;
	if (!block_ptr->next)
		end = block_ptr;
	allocated -= block_ptr->size + sizeof(%BlockMeta);
	merge();
}

u64 merge() {
	u64 count = 0u64;
	%BlockMeta* current = base;
	while (current && current->next) {
		if (current->free && current->next->free) {
			current->size += sizeof(%BlockMeta) + current->next->size;
			current->next = current->next->next;
			++count;
		} else
			current = current->next;
	}

	return count;
}

void setBounds(void* new_start, void* new_high) {
	if (new_high <= new_start) {
		p("Invalid heap bounds: 0x");
		asm("<prx $1>":new_start);
		p(" through 0x");
		asm("<prx $1>":new_high);
		p('\n');
		asm("<halt>");
	}
	start = (void*) realign((u64) new_start, MEMORY_ALIGN);
	highestAllocated = (u64) start;
	high = new_high;
	end = new_start;
}

u64 getUnallocated() {
	return (u64) (high - start) - allocated;
}

void* malloc(u64 size) {
	return allocate(size, MEMORY_ALIGN);
}

void* memset(void* ptr, u8 c, u64 len) {
	asm("memset $1 x $2 -> $3":len, c, ptr);
	return ptr;
}

void* calloc(u64 count, u64 size) {
	void* chunk = malloc(count * size);
	if (chunk)
		memset(chunk, 0, count * size);
	return chunk;
}

void* new(u64 size) {
	void* out = malloc(size);
	if (!out) {
		p("Can't allocate ");
		p(size);
		p(" bytes: out of memory\n");
		asm("<halt>");
	}
	return out;
}

u64 roundUp(u64 value) {
	--value;
	value |= value >> 1u64;
	value |= value >> 2u64;
	value |= value >> 4u64;
	value |= value >> 8u64;
	value |= value >> 16u64;
	value |= value >> 32u64;
	return ++value;
}
