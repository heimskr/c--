#name "Mal"
#author "Kai Tamkun"
#orcid "0000-0001-7405-6654"
#version "0.3"

struct BlockMeta;

u64 MEMORY_ALIGN = 32;
u64 allocated = 0;
struct BlockMeta* base = (struct BlockMeta*) 0;
u64 highestAllocated = 0;
void* start = (void*) 0;
void* high = (void*) 0;
void* end = (void*) 0;

struct BlockMeta {
	u64 size;
	struct BlockMeta* next;
	bool free;
};

u64 realign(u64 val, u64 alignment) {
	if (alignment == 0u64)
		return val;
	u64 offset = (val + sizeof(struct BlockMeta)) % alignment;
	if (offset)
		val = val + alignment - offset;
	return val;
}

struct BlockMeta* findFreeBlock(struct BlockMeta** last, u64 size) {
	struct BlockMeta* current = base;
	while ((s64) current != 0 && !(current->free && size <= current->size)) {
		*last = current;
		current = current->next;
	}
	return current;
}

struct BlockMeta* requestSpace(struct BlockMeta* last, u64 size, u64 alignment) {
	struct BlockMeta* block = (struct BlockMeta*) realign((u64) end, alignment);

	if (last != (struct BlockMeta*) 0)
		last->next = block;

	block->size = size;
	block->next = (struct BlockMeta*) 0;
	block->free = false;

	end = (u8*) block + block->size + sizeof(struct BlockMeta) + 1;
	return block;
}

void* allocate(u64 size, u64 alignment) {
	struct BlockMeta* block = (struct BlockMeta*) 0;

	if (size <= 0u64)
		return (void*) 0;

	if (!base) {
		block = requestSpace((struct BlockMeta*) 0, size, alignment);
		if (!block)
			return (void*) 0;
		base = block;
	} else {
		struct BlockMeta* last = base;
		block = findFreeBlock(&last, size);
		if (!block) {
			block = requestSpace(last, size, alignment);
			if (!block)
				return (void*) 0;
		} else {
			split(block, size);
			block->free = false;
		}
	}

	allocated = allocated + block->size + sizeof(struct BlockMeta);
	return block + 1;
}

void* split(struct BlockMeta* block, u64 size) {
	if (block->size > size + sizeof(struct BlockMeta)) {
		// We have enough space to split the block, unless alignment takes up too much.
		struct BlockMeta* new_block = (struct BlockMeta*) realign((u64) block + size + sizeof(struct BlockMeta) + 1u64, MEMORY_ALIGN);

		// After we realign, we need to make sure that the new block's new size isn't negative.

		if (block->next != (struct BlockMeta*) 0) {
			u64 new_size = (u64) ((void*) block->next - (void*) new_block - sizeof(struct BlockMeta));

			// Realigning the new block can make it too small, so we need to make sure the new block is big enough.
			if (new_size > 0u64) {
				new_block->size = new_size;
				new_block->free = true;
				new_block->next = block->next;
				block->next = new_block;
				block->size = size;
			}
		} else {
			u64 new_size = (u64) ((void*) block + block->size - (void*) new_block);

			if (new_size > 0u64) {
				new_block->size = new_size;
				new_block->free = true;
				new_block->next = (struct BlockMeta*) 0;
				block->size = size;
				block->next = new_block;
			}
		}
	}
}

struct BlockMeta* getBlock(void* ptr) {
	return (struct BlockMeta*) ptr - 1;
}

void free(void* ptr) {
	if (ptr == (void*) 0)
		return;
	struct BlockMeta* block_ptr = getBlock(ptr);
	block_ptr->free = true;
	allocated = allocated - block_ptr->size + sizeof(struct BlockMeta);
	merge();
}

u64 merge() {
	u64 count = 0u64;
	struct BlockMeta* current = base;
	while (current != (struct BlockMeta*) 0 && current->next != (struct BlockMeta*) 0) {
		if ((current->free) && (current->next->free)) {
			current->size = current->size + sizeof(struct BlockMeta) + current->next->size;
			current->next = current->next->next;
			++count;
		} else
			current = current->next;
	}

	return count;
}